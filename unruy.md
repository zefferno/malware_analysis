# Unruy sample analysis report
###### Report written by zefferno (zefferno@gmail.com)
###### September 2017

> https://www.virustotal.com/#/file/0eae5c72e863efb1907befc7bdb89d82f77f8b85d7ce5f56d2cbfa2ba07ce4ef


## Summary
The sample is identified by majority of malware detection signatures as a variant of the Unruy family of malwares. 
There is an high ratio of detection in VirusTotal (60 / 65).  According to Microsoft and Trend-Micro advisories, Unruy 
family of malwares are classified as a trojans capable to display intrusive and unwanted advertisements to victims, and 
to perform click-fraud to generate revenues for cyber-criminals. Unruy variants could be delivered during Malvertising 
campaigns, injecting malicious ads into online advertisement networks, using techniques such as drive-by-downloads, 
web widgets, compromised applets or webpages.

This sample consist of a multi-threaded application. Each thread plays a different role in the malware functionality. 
It contains several techniques employed to conceal it from being reverse-engineered. It has a self-replication mechanism 
with Trojan capabilities, such as screenshot grabbing, CRUD operations on files, perform shutdown, and additional 
potentially malicious commands. 

The remote Command and Control (C&C) domain that it is designed to contact is currently deactivated. Thus, there is 
no significant impact of infected with this sample.

I assume that this malware is originated from China. A separate section in this paper describes the reasons for 
this assumption.

## Analysis Scope
Due to limited time allocated for this research, which is done during my free time at nights, while working full 
time job, this research will focus on the self-replication mechanism that the sample uses. 

The objective is to find out whether they are any methods to gain persistence on system, and how it could aid 
in finding countermeasures.

## Characteristics

File properties

|Property   | Value                                   |
|-----------|:---------------------------------------:|
| Filename  | dd103c337b8fa74ccd848a5b68f22ed0.virobj |
| Timestamp | 2010-06-23 10:43:48                     |
| File-type | 32-bit GUI application                  |
| Compiler  | Microsoft Visual C++                    |

AV detection names/aliases

|Vendor     | Signature detection name   |
|-----------|:--------------------------:|
| Avast     | Win32:Unruy-W [Trj]        |
| F-Secure  | Gen:Variant.Unruy.5        |
| Kaspersky | HEUR:Trojan.Win32.Generic  |
| McAfee    | Downloader-BZH.gen.a       |
| Symantec  | Trojan.Artilyb             |

Initial assessment
* No well-known signatures for packer/crypter tools were detected by serval PE utilities. 
* File entropy statistical value: **6.392** is less the expected statistical minimum (6.8~) to be considered packed.
* Dynamic analysis in Hybrid-Analysis sandbox reports high threat score (98/100).
* The malware tries to connect to **ns.dns3-domain.com**.
* There are string references to "inflate", a zlib based compression library that the malware might be using for decompression of content.
* Static obfuscation tool for strings reveals a string for domain ns.dns3-domain.com embedded in the file (.data section:0004BC14).


## Behavioral and code analysis findings
The disassembly output reveals obfuscated code, I could not locate any interested strings to start my analysis with. The import table 
imports only very few functions from the KERNEL32 library. There are references for LoadLibraryA and GetModuleHandleA functions, 
this usually imply on dynamic DLL loading, a common technique used by malware authors to conceal library names from static analysis.  
Cross-references to those functions reveals a subroutine that dynamically constructs library names, loads them into memory, and save 
their memory location using GetProcAddress. 

The following example demonstrates the use with CreateFileA function. The eax register gets pointed at the start of the memory location 
with offset that points the relevant function address that was stored earlier. In this case eax+50h points to kernel32_CreateFileA.
```asm
mov     eax, function_resolve_4293D0
call    dword ptr [eax+50h] ; kernel32_CreateFileA
```
In the appendix section, I have listed the entire API resolve table used by the malware during runtime.

### Junk blocks
The entire sections of the code contain a pattern of using junk code blocks, inside subroutines that makes use of GetCurrentDirectoryA 
and SetCurrentDirectoryA APIâ€™s without no real propose. Those code blocks are used to make the code look complex and much 
harder to reverse-engineer.

### Initialization process
The malware starts by creating an event with the name: {AB8D393B-9177-440D-B3F8-1C1FE0CF9692}. 
The name is hardcoded, and indicates a state to be used by the malware later. It tries to check for existing event with the 
name {A37340FD-F043-41e3-9C16-2F2632387199}, at first run, the event is not registered in the system. The malware loads the 
content of the running filename using CreateFileA, ReadFile and CloseHandle.

### Threads creation
When the malware is fully initialized, it runs 9 process threads. Each one of them plays a role in the entire malware operation. 

The following table lists all running threads, a time critical TID 356 gets created by winmm.dll, a Windows Multimedia 
API which provides time event functions, for example: timeGetSystemTime, which is used delay the execution of the code.

![unruy threads](https://github.com/zefferno/malware_analysis/blob/master/unruy_threads.png)

The first thread that gets created contains the self-replication mechanism, which I will be focus on.

### Self-replication thread
When the new thread is created it waits for 30 seconds in WaitForSingleObject, then it proceeds to run on loop. The loop calls CreateToolhelp32Snapshot, Process32First and OpenProcess to interrogate running processes to find potential targets for the 
self-replication routine that gets executed later. 

Between process snapshots it waits for 5 seconds in WaitForSingleObject. It saves state of potential targets, and it keeps 
replicating itself on new potential targets, as long as the thread is running.



