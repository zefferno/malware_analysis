# Unruy sample analysis report
> https://www.virustotal.com/#/file/0eae5c72e863efb1907befc7bdb89d82f77f8b85d7ce5f56d2cbfa2ba07ce4ef

###### Report written by zefferno (zefferno@gmail.com)
###### September 2017



## Summary
The sample is identified by majority of malware detection signatures as a variant of the Unruy family of malwares. 
There is an high ratio of detection in VirusTotal (60 / 65).  According to Microsoft and Trend-Micro advisories, Unruy 
family of malwares are classified as a trojans capable to display intrusive and unwanted advertisements to victims, and 
to perform click-fraud to generate revenues for cyber-criminals. Unruy variants could be delivered during Malvertising 
campaigns, injecting malicious ads into online advertisement networks, using techniques such as drive-by-downloads, 
web widgets, compromised applets or webpages.

This sample consist of a multi-threaded application. Each thread plays a different role in the malware functionality. 
It contains several techniques employed to conceal it from being reverse-engineered. It has a self-replication mechanism 
with Trojan capabilities, such as screenshot grabbing, CRUD operations on files, perform shutdown, and additional 
potentially malicious commands. 

The remote Command and Control (C&C) domain that it is designed to contact is currently deactivated. Thus, there is 
no significant impact of infected with this sample.

I assume that this malware is originated from China. A separate section in this paper describes the reasons for 
this assumption.

## Analysis Scope
Due to limited time allocated for this research, which is done during my free time at nights, while working full 
time job, this research will focus on the self-replication mechanism that the sample uses. 

The objective is to find out whether they are any methods to gain persistence on system, and how it could aid 
in finding countermeasures.

## Characteristics

File properties

|Property   | Value                                   |
|-----------|:---------------------------------------:|
| Filename  | dd103c337b8fa74ccd848a5b68f22ed0.virobj |
| Timestamp | 2010-06-23 10:43:48                     |
| File-type | 32-bit GUI application                  |
| Compiler  | Microsoft Visual C++                    |

AV detection names/aliases


|Vendor     | Signature detection name   |
|-----------|:--------------------------:|
| Avast     | Win32:Unruy-W [Trj]        |
| F-Secure  | Gen:Variant.Unruy.5        |
| Kaspersky | HEUR:Trojan.Win32.Generic  |
| McAfee    | Downloader-BZH.gen.a       |
| Symantec  | Trojan.Artilyb             |

Initial assessment
* No well-known signatures for packer/crypter tools were detected by serval PE utilities. 
* File entropy statistical value: **6.392** is less the expected statistical minimum (6.8~) to be considered packed.
* Dynamic analysis in Hybrid-Analysis sandbox reports high threat score (98/100).
* The malware tries to connect to **ns.dns3-domain.com**.
* There are string references to "inflate", a zlib based compression library that the malware might be using for decompression of content.
* Static obfuscation tool for strings reveals a string for domain ns.dns3-domain.com embedded in the file (.data section:0004BC14).

## Behavioral and code analysis findings
The disassembly output reveals obfuscated code, I could not locate any interested strings to start my analysis with. The import table 
imports only very few functions from the KERNEL32 library. There are references for LoadLibraryA and GetModuleHandleA functions, 
this usually imply on dynamic DLL loading, a common technique used by malware authors to conceal library names from static analysis.  
Cross-references to those functions reveals a subroutine that dynamically constructs library names, loads them into memory, and save 
their memory location using GetProcAddress. 

The following example demonstrates the use with CreateFileA function. The eax register gets pointed at the start of the memory location 
with offset that points the relevant function address that was stored earlier. In this case eax+50h points to kernel32_CreateFileA.
```asm
mov     eax, function_resolve_4293D0
call    dword ptr [eax+50h] ; kernel32_CreateFileA
```
In the appendix section, I have listed the entire API resolve table used by the malware during runtime.

### Junk blocks
The entire sections of the code contain a pattern of using junk code blocks, inside subroutines that makes use of GetCurrentDirectoryA 
and SetCurrentDirectoryA APIâ€™s without no real propose. Those code blocks are used to make the code look complex and much 
harder to reverse-engineer.

### Initialization process
The malware starts by creating an event with the name: {AB8D393B-9177-440D-B3F8-1C1FE0CF9692}. 
The name is hardcoded, and indicates a state to be used by the malware later. It tries to check for existing event with the 
name {A37340FD-F043-41e3-9C16-2F2632387199}, at first run, the event is not registered in the system. The malware loads the 
content of the running filename using CreateFileA, ReadFile and CloseHandle.

### Threads creation
When the malware is fully initialized, it runs 9 process threads. Each one of them plays a role in the entire malware operation. 

The following table lists all running threads, a time critical TID 356 gets created by winmm.dll, a Windows Multimedia 
API which provides time event functions, for example: timeGetSystemTime, which is used delay the execution of the code.

![unruy threads](https://github.com/zefferno/malware_analysis/blob/master/unruy_threads.png)

The first thread that gets created contains the self-replication mechanism, which I will be focus on.

### Self-replication thread
When the new thread is created it waits for 30 seconds in WaitForSingleObject, then it proceeds to run on loop. The loop calls CreateToolhelp32Snapshot, Process32First and OpenProcess to interrogate running processes to find potential targets for the 
self-replication routine that gets executed later. 

Between process snapshots, it waits for 5 seconds in WaitForSingleObject. It saves state of potential targets, and it keeps 
replicating itself, as long as the thread is running.

### Finding target for self-replication
The malware selects a target process by looking at its properties, process file extension and size, and it also matches the 
full path to the filename against a list of blacklisted wildcards:

* \eset nod32 anti virus\
* \temp\
* :\windows\
* Netthief
* exebinder
* \qq
* visual studio
* \microsoft office\
* \skynet\
* \thunder\
* \360\
* \aliwangwang\
* \internet
* \outlook
* \microsoft sql server\
* \windows live \messenger\
* \winzip\
* \winrar\
* \globalink\game\
* \qqdoctor\
* \rising\
* firefox\
* \aliim.exe
* \avira\
* \world of warcraft\

When it finds a proper target, it calls the self-replication routine to replace its process image file on the filesystem.

### Self-replication routine
The malware uses SHFileOperation to remove the file extension from the process file, it uses GetFileAttributesA and 
SetFileAttributesA to set the file attribute to be hidden, then it loads a copy of the malware file, and writes it 
as the target process image filename using WriteFile. To make the file look authentic in the UI, it preserves 
the original icon of the file. 

The following example demonstrates the visual result of file infection on ProcessHacker.exe file. 
The malware renames the original file (1,431 KB in size) to remove its extension, and sets it as hidden, then it 
replicates as the original file, while preserving the original icon from the original file.

![unruy process infection](https://github.com/zefferno/malware_analysis/blob/master/unruy_process.png)

### Malware origin
The Command-and-Control (C&C) domain: ns.dns3-domain.com points to a C&C server that is linked to several other 
malwares found in the wild. It is currently registered for a company name "New Ventures Services, Corp" located in the US. 

Domain registry records shows references to name servers in domains: hichina.com, parktons.com, and reg.ru domains. 
The first NS is originated on China, and the last NS record is registered in Russia. 

The following threat intelligence relations diagram shows the connections to objects that had relations to this domain, 
some are hashes for malwares that contacts this domain.

![unruy intelligence](https://github.com/zefferno/malware_analysis/blob/master/unruy_intel.png)

Considering the compilation date and the domain registration date, I believe that the malware author originates from China.

### Countermeasures and Indicators of Compromise

```yara
/*
	Yara signature for detecting UNRUY malware sample
	Written by: Mor Kalfon (zefferno@gmail.com)
*/

rule UNRUY: malware {
 
meta:
  description = "UNRUY malware variant static detection"
  author = "Mor Kalfon"
  date = "14/09/2017"
 
strings:
   $event_id_1 = {
   	6A 7D 6A 39 6A 39 6A 31 6A 37 6A 38 6A 33 58 
   	50 6A 32 50 6A 36 6A 32 6A 46 6A 32 6A 2D 59 
   	51 6A 36 6A 31 6A 43 6A 39 51 50 6A 65 6A 31 
   	6A 34 51 50 6A 34 6A 30 6A 46 51 6A 44 6A 46 
   	6A 30 6A 34 50 6A 37 50 6A 41 8D 45 8C 6A 7B
   }
   $event_id_2 = {
   	6A 7D 6A 39 6A 39 6A 31 6A 37 6A 38 6A 33 58 
   	50 6A 32 50 6A 36 6A 32 6A 46 6A 32 6A 2D 59 
   	51 6A 36 6A 31 6A 43 6A 39 51 50 6A 65 6A 31 
   	6A 34 51 50 6A 34 6A 30 6A 46 51 6A 44 6A 46 
   	6A 30 6A 34 50 6A 37 50 6A 41 8D 45 8C 6A 7B
   }

condition:
		uint16(0) == 0x5A4D and  		// MZ signature
		uint16(uint32(0x3C)+0x18) == 0x010B and  // PE signature
		uint16(uint32(0x3C)+0x5C) == 0x0002 and  // Windows GUI subsystem
		any of ($event_id*)
}
```

Original sample hash:
* 0eae5c72e863efb1907befc7bdb89d82f77f8b85d7ce5f56d2cbfa2ba07ce4ef

Contact domains:
* ns.dns3-domain.com

### Appendix
The following table lists all the imported functions and their offsets that the sample uses to call library functions:

**Offset**|**Function Name**|**DLL library**
:-----:|:-----:|:-----:
4|Process32Next|KERNEL32.DLL
8|Process32First|KERNEL32.DLL
C|CreateToolHelp32Snapshot|KERNEL32.DLL
10|TerminateProcess|KERNEL32.DLL
14|CreateProcessA|KERNEL32.DLL
18|OpenProcess|KERNEL32.DLL
1C|GetExitCodeProcess|KERNEL32.DLL
20|GetCurrentProcess|KERNEL32.DLL
24|GetCurrentProcessId|KERNEL32.DLL
28|CreatePipe|KERNEL32.DLL
2C|DuplicateHandle|KERNEL32.DLL
30|OpenEventA|KERNEL32.DLL
34|CreateThread|KERNEL32.DLL
38|GetFileSize|KERNEL32.DLL
3C|Sleep|KERNEL32.DLL
40|DeleteFileA|KERNEL32.DLL
44|CloseHandle|KERNEL32.DLL
48|SetEvent|KERNEL32.DLL
4C|ReadFile|KERNEL32.DLL
50|CreateFileA|KERNEL32.DLL
54|GetTempPathA|KERNEL32.DLL
58|GetSystemDirectoryA|KERNEL32.DLL
5C|GetWindowsDirectoryA|KERNEL32.DLL
60|FindClose|KERNEL32.DLL
64|FindFirstFileA|KERNEL32.DLL
68|CreateEventA|KERNEL32.DLL
6C|TerminateThreadA|KERNEL32.DLL
70|WaitForSingleObject|KERNEL32.DLL
74|GetModuleFileNameA|KERNEL32.DLL
78|WriteFile|KERNEL32.DLL
7C|ResetEvent|KERNEL32.DLL
80|WaitForMultipleObjects|KERNEL32.DLL
84|GetShortPathNameA|KERNEL32.DLL
88|CreateDirectoryA|KERNEL32.DLL
8C|GetTickCount|KERNEL32.DLL
90|SetFileAttributesA|KERNEL32.DLL
94|GetFileAttributesA|KERNEL32.DLL
98|MultiByteToWideChar|KERNEL32.DLL
9C|GetQueuedCompletionStatus|KERNEL32.DLL
A0|PostQueuedCompletionStatus|KERNEL32.DLL
A4|CreateIoCompletionPort|KERNEL32.DLL
A8|GetDriveTypeA|KERNEL32.DLL
AC|GetVolumeInformationA|KERNEL32.DLL
B0|SetFilePointer|KERNEL32.DLL
B4|GetLongPathNameA|KERNEL32.DLL
B8|FindNextFileA|KERNEL32.DLL
BC|EnterCriticalSection|KERNEL32.DLL
C0|LeaveCriticalSection|KERNEL32.DLL
C4|DeleteCriticalSection|KERNEL32.DLL
C8|InitializeCriticalSection|KERNEL32.DLL
CC|GetExitCodeThread|KERNEL32.DLL
D0|GetLastError|KERNEL32.DLL
D4|GetModuleFileNameExA|PSAPI.DLL
D8|EnumProcessModules|PSAPI.DLL
DC|capCreateCaptureWindowA|AVICAP32.dll
E0|capGetDriverDescriptionA|AVICAP32.dll
E4|RegCloseKey|ADVAPI32.DLL
E8|RegEnumValueA|ADVAPI32.DLL
EC|RegQueryInfoKeyA|ADVAPI32.DLL
F0|RegOpenKeyExA|ADVAPI32.DLL
F4|OpenProcessToken|ADVAPI32.DLL
F8|AdjustTokenPrivileges|ADVAPI32.DLL
FC|LookupPrivilegeValueA|ADVAPI32.DLL
100|timeSetEvent|WINMM.DLL
104|timeKillEvent|WINMM.DLL
108|CoUninitialize|OLE32.DLL
10C|CoCreateGuid|OLE32.DLL
110|CoInitialize|OLE32.DLL
114|SHFileOperationA|SHELL32.DLL
118|ShellExecuteA|SHELL32.DLL
11C|WSAIoctl|WS2\_32.DLL
120|socket|WS2\_32.DLL
124|closesocket|WS2\_32.DLL
128|bind|WS2\_32.DLL
12C|gethostbyname|WS2\_32.DLL
130|WSAStartup|WS2\_32.DLL
134|WSACleanup|WS2\_32.DLL
138|ntohs|WS2\_32.DLL
13C|sendto|WS2\_32.DLL
140|ntohs|WS2\_32.DLL
144|WSAGetLastError|WS2\_32.DLL
148|recvfrom|WS2\_32.DLL
14C|getsockname|WS2\_32.DLL
150|shutdown|WS2\_32.DLL
154|connect|WS2\_32.DLL
158|send|WS2\_32.DLL
15C|recv|WS2\_32.DLL
160|gethostname|WS2\_32.DLL
164|DeleteObject|GDI32.DLL
168|GetDIBits|GDI32.DLL
16C|GetObjectA|GDI32.DLL
170|BitBit|GDI32.DLL
174|SelectObject|GDI32.DLL
178|CreateCompatibleDC|GDI32.DLL
17C|CreateCompatibleBitmap|GDI32.DLL
180|CreateDCA|GDI32.DLL
184|DeleteDC|GDI32.DLL
188|GdipGetImageEncoders|GDIPLUS.DLL
18C|GdipGetImageEncodersSize|GDIPLUS.DLL
190|GdipDisposeImage|GDIPLUS.DLL
194|GdipSaveImageToFile|GDIPLUS.DLL
198|GdipLoadImageFromFile|GDIPLUS.DLL
19C|GdiplusStartup|GDIPLUS.DLL
1A0|GdiplusShutdown|GDIPLUS.DLL
1A4|GetWindowThreadProcessId|USER32.DLL
1A8|ExitWindowsEx|USER32.DLL
1AC|GetWindowTextA|USER32.DLL
1B0|GetWindowLongA|USER32.DLL
1B4|GetWindow|USER32.DLL
1B8|GetDesktopWindow|USER32.DLL
1BC|PostMessageA|USER32.DLL
1C0|FindWindowA|USER32.DLL
1C4|GetSystemMetrics|USER32.DLL
1C8|DestroyWindow|USER32.DLL
1CC|SendMessageA|USER32.DLL
1D0|IsWindow|USER32.DLL
1D4|PostThreadMessageA|USER32.DLL
1D8|GetMessageA|USER32.DLL
1DC|sprintf|MSVCRT.DLL
1E0|strcmp|MSVCRT.DLL
1E4|strstr|MSVCRT.DLL
1E8|strcpy|MSVCRT.DLL
1EC|strrchr|MSVCRT.DLL
1F0|strrchr|MSVCRT.DLL
1F4|strchr|MSVCRT.DLL
1F8|memcmp|MSVCRT.DLL
1FC|srand|MSVCRT.DLL
200|rand|MSVCRT.DLL
204|wcscmp|MSVCRT.DLL
208|pow|MSVCRT.DLL
20C|strupr|MSVCRT.DLL
210|\_strlwr|MSVCRT.DLL
214|\_strset|MSVCRT.DLL
218|strcat|MSVCRT.DLL
21C|memset|MSVCRT.DLL
